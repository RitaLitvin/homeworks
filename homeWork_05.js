// 1) Какие бывают алгоритмы сортировок ?

/* 1. Сортировка пузырьком. Алгоритм заключается в сравнении пары соседних значений. Например, сортировка массива [2, 4, 3, 5] по возрастанию будет происходить следующим образом:
- сравниваются 2 и 4, т.к. 4 > 2, порядок остаётся тем же.
- сравниваются 4 и 3, т.к. 3 < 4, они меняются местами.
- сравниваются 4 и 5, т.к. 4 < 5, порядок остаётся тем же.
В итоге получаем массив [2, 3, 4, 5].
Сложность алгоритма составляет O(n^2), так как его реализация выглядит как цикл вложенный в цикл.

2. Сортировка выбором. Сначала алгоритм сравнивает и находит наименьший элемент, а затем помещает его в начало. На следующем проходе массива первый элемент исключается из сравнения и снова ищется наименьшее значение в массиве, которое помещается на вторую позицию. Например, сортировка массива [3, 2, 7, 5, 1] будет происходить следующим образом:
- ищется минимальное значение в массиве и ставится в начало: [1, 3, 2, 7, 5].
- первый пункт повторяется, но поиск минимального значения начинается со второго элемента: [1, 2, 3, 7, 5].
- и т.д. пока массив не будет отсортирован.
Сложность алгоритма составляет O(n^2), так как он требует вложенности циклов.

3. Сортировка вставками.
- Начиная со второго элемента происходит сравнение, должен ли элемент стать на первую позицию или остаться на текущей.
- На второй итерации третий элемент сравнивается с двумя предыдущими и становится на соответсвующее место.
- На третьей итерации четвертый элемент сравнивается с тремя предыдущими и становится на соответсвующее место и т.д.
Сложность алгоритма составляет O(n^2), так как он требует вложенности циклов.

4. Сортировка слиянием.
- Массив разбивается на подмассивы длиной в один элемент. [5, 2, 7, 4] => [5, 2] и [7, 4] => [5] и [2], [7] и [4].
- Сравнивается 5 с 2 и сливается в массив [2, 5].
- Сравнивается 7 с 4 и сливается в массив [4, 7].
- Сравнивается 2 с 4, в итоговый массив заносится 2. Сравнивается 5 и 4, в итоговый массив заносится 4. Сравнивается 5 и 7, в итоговый массив заносится 5, затем 7. [2, 4, 5, 7]
Сложность алгоритма составляет O(n log n), так как мы в цикле сравниваем значения подмассивов (O(n)) и разбиваем первоначальный массив на подмассивы делением на 2 (O(log n)).

5. Быстрая сортировка.
- Выбирается опорное значение в массиве, обычно это центральный элемент массива.
- Сравниваем левые и правые значения с опорным значением. Если значение меньше опорного, то оно становится слева от него, если больше - то справа.
- Для получившихся подмассивов (левый и правый) повторяются первые два этапа (выбирается опорный элемент, с ним сравниваются значения, которые затем становятся либо слева, либо справа от опорного элемента). Так продолжается до тех пор, пока подмассив не будет состоять из 1 элемента.
Сложность алгоритма составляет в среднем случае O(n log n), так как мы в цикле сравниваем значения массива/подмассивов с опорным (O(n)) и разбиваем массив/подмассивы на левый и правый подмассивы (O(log n)), в худшем случае О(n^2).

*/
// 3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были
// доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.

const person = {
  name: 'Rita',
  email: '@gmail.com',
  showFullInfo: function () {return 'name: ' + this.name + ' email: ' + this.email}
}

// const personSecondWay = Object.create({}, {
//   name: {writable: true, enumerable: true, configurable: true, value: 'Rita'},
//   email: {writable: true, enumerable: true, configurable: true, value: '@gmail.com'}
// })
// personSecondWay.showFullInfo = function () {return 'name: ' + this.name + ' email: ' + this.email}

// function Person (name, email) {
//   this.name = name;
//   this.email = email;
//   this.showFullInfo = function () {return 'name: ' + this.name + ' email: ' + this.email}
// }

// const personThirdWay = new Person('Rita', '@gmail.com')

const person2 = {
  name: 'Margarita',
  __proto__: person
}

person.__proto__.logInfo = function () {
  console.log('I log info about ' + this.name + this.email)
}

// 4) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от
// класса Person.

class PersonThree {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }
  get getName() {
    return this.name;
  }
  set setName(value) {
    this.name = value
  }
}

class PersonFour extends PersonThree {
  constructor (name, email, age) {
    super(name, email);
    this.age = age
  }
}

// Бонус 1 Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total :

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
// максимально возможная сумма = 17
// минимально возможная сумма = 3
// до total = 10 включительно можно собрать пару из 1 и числа из массива
// после total = 10 можно собрать пару из числа из массива и 9

const total = 13;

const firstSum = (arr, total) => {
  const basicValue = (total <= 10) ? 1 : 9

  const variableValue = arr.filter((item) => basicValue + item === total)

  const result = (basicValue === 1) ? [basicValue, ...variableValue] : [...variableValue, basicValue]

  return (total >= 18 || total <= 2) ? 'Нет такой пары' : result
}
console.log(firstSum(arr, total))

// 2) Какая сложность у вашего алгоритма ?
// Cложность алгоритма составляет О(n), т.к. мы итерируемся по массиву методом filter.