/*
1)

console.log('1');
setTimeout(() => console.log('2'), 1);
let promiseNew = new Promise((resolve) => {
console.log('3');
resolve();
});
promiseNew.then(() => console.log('4'));
setTimeout(() => console.log('5'));
console.log('6');
*/

/*
1. синхронный код (выполняется первым):
console.log('1');
console.log('3') - при создании промиса код функции-исполнителя выполняется сразу;
console.log('6');
2. очередь микрозадач (выполняются после выполнения синхронного кода):
.then(() => console.log('4'));
3. очередь макрозадач (выполняются по одной после выполнения всех микрозадач):
setTimeout(() => console.log('2'), 1); - выполнится последней, т.к. таймер = 1 с больше, чем у следующей макрозадачи
setTimeout(() => console.log('5'))

В консоль выведется:
1, 3, 6, 4, 5, 2
*/

/*
2)

let promiseTree = new Promise((resolve, reject) => {
    resolve("a");
    console.log("1");
    setTimeout(() => {
    console.log("2");
    }, 0);
    console.log("3");
    });
*/

/*
1. синхронный код (выполняется первым):
console.log("1");
console.log("3");
2. очередь микрозадач (выполняются после выполнения синхронного кода):
-
3. очередь макрозадач (выполняются по одной после выполнения всех микрозадач):
setTimeout(() => {console.log("2")}, 0);

В консоль выведется:
1, 3, 2

То есть выполнится весь синхронный код (1, 3), очередь микрозадач пустая, поэтому далее выполниться выполнится единственная макрозадача (2)
*/

/*
3)

let promiseTwo = new Promise((resolve, reject) => {
    resolve("a");
});
promiseTwo
.then((res) => {
return res + "b";
})
.then((res) => {
return res + "с";
})
.finally((res) => {
return res + "!!!!!!!";
})
.catch((res) => {
return res + "d";
})
.then((res) => {
console.log(res);
});
*/

/*
1. синхронный код (выполняется первым):
-
2. очередь микрозадач (выполняются после выполнения синхронного кода):
.then((res) => {return res + "b";})
.then((res) => {return res + "с";})
.then((res) => {console.log(res);});
3. очередь макрозадач (выполняются по одной после выполнения всех микрозадач):
-

В консоль выведется:
abc

Так как в переменной promiseTwo находится успешно выполненный промис со значением 'a', то далее выполняется код в методах .then (строка 'a' объединяется со строкой 'b' и 'c' ). Метод .finally пропускает предыдущий результат в следующий обработчик. Метод .catch используется для обработки ошибок, в нашем случае он игнорируется, т.к. у нас успешно выполненный промис. Далее выполняется код в последнем обработчике then.
*/

/*
4)

function doSmth() {
    return Promise.resolve("123");
    }
    doSmth()
    .then(function (a) {
    console.log("1", a); //
    return a;
    })
    .then(function (b) {
    console.log("2", b);
    return Promise.reject("321");
    })
    .catch(function (err) {
    console.log("3", err);
    })
    .then(function (c) {
    console.log("4", c);
    return c;
    });

*/

/*
1. синхронный код (выполняется первым):
-
2. очередь микрозадач (выполняются после выполнения синхронного кода):
- все обработчики созданного промиса
3. очередь макрозадач (выполняются по одной после выполнения всех микрозадач):
-

В консоль выведется:
1, 123, 2, 123, 3, 321, 4, undefined

Результатом вызова функции doSmth будет успешно выполненный промис со значением '123', значит далее выполняется код в методе .then (1, 123). В следующий обработчик .then передается значение '123', в консоль выводится 2, 123 и возвращается новый отклоненный промис со значением '321'. Так как промис отклоненный, то выполняется код в методе .catch, в консоль выводится 3, 321. Сatch успешно отработал, поэтому выполняется код в последнем методе .then, в консоль выводится 4, undefined, т.к. нам не вернулось значение из вышестоящего обработчика catch.
*/

/*
5)

console.log("1");
setTimeout(function () {
console.log("2");
}, 0);
Promise.resolve().then(() => console.log("3"));
console.log("4");

*/

/*
1. синхронный код (выполняется первым):
console.log("1");
console.log("4");
2. очередь микрозадач (выполняются после выполнения синхронного кода):
.then(() => console.log("3"))
3. очередь макрозадач (выполняются по одной после выполнения всех микрозадач):
setTimeout(function () { console.log("2");}, 0);

В консоль выведется:
1, 4, 3, 2

Сначала выполнится синхронный код (1, 4), затем микрозадача (3), затем макрозадача (2)
*/

/* 6) Напишите функцию, которая будет проходить через массив целых чисел и выводить индекс каждого
элемента с задержкой в 3 секунды.
Входные данные: [10, 12, 15, 21] */

const arr = [10, 12, 15, 21];

function showIndexDelay () {
  const indexes = Object.keys(arr);
  let pointer = 0;

  setTimeout(function timer() {
    console.log(indexes[pointer])
    pointer++
    (pointer < arr.length) ? setTimeout(timer, 3000) : clearInterval(timer);
  }, 3000)
}

showIndexDelay ()

/* Задание "со звёздочкой":

1) Сначала без запуска подцумайте какой будет порядок вывода в консоль
2) Скопируйте и запустите код в любой консоли
3) А дальше прикрипите к дз подробное обьяснение по шагам о работе эвент лупа в этом коде и собственно объяснение почему выведеться именно в таком порядке
*/

Promise.resolve()
  .then(() => console.log("a: 1"))
  .then(() => {
    setTimeout(() => console.log("timeout 2"));
    console.log("a: 2");
  })
  .then(() => {
    setTimeout(() => console.log("timeout 3"));
    console.log("a: 3");
  });

new Promise((res, rej) => {
  console.log("b");
  rej(new Error("123"));
})
  .then(console.log("b 1"))
  .then(
    () => console.log("b 2"),
    () => console.log("b")
  )
  .catch(() => console.log("b 3"))
  .then(() => console.log("b 4"));


// В консоль выведется: b, b 1, a: 1, a: 2, b, a: 3, b 4, timeout 2, timeout 3

/* Данные промисы будут выполняться параллельно.

1. синхронный код (выполняется первым):
console.log("b")
.then(console.log("b 1")) - не функция-коллбек, а простой синхронный код

2. очередь микрозадач (выполняются после выполнения синхронного кода):
.then(() => console.log("a: 1") - выполнится первой после синхронного кода)
.then(() => {
    setTimeout(() => console.log("timeout 2")) - микрозадача порождает макрозадачу;
    console.log("a: 2") - выполнится второй после синхронного кода;
  })
.then(() => {
    setTimeout(() => console.log("timeout 3")); - микрозадача порождает макрозадачу;
    console.log("a: 3") - Выполнится четвертой после синхронного кода, не могу объяснить почему :(;
.then(
    () => console.log("b 2") - эта коллбек-функция будет проигнорирована,
    () => console.log("b") - будет выполнятся эта коллбек-функция, т.к. вышестоящий промис был отклонен. Второй аргумент метода .then используется для обработки ошибок. Выполнится третьей после синхронного кода, не могу объяснить почему :(
  )
.then(() => console.log("b 4") - так как предыдущий .then успешно обработал ошибку, будет выполняться этот код, а блок catch будет проигнорирован);

3. очередь макрозадач (выполняются по одной после выполнения всех микрозадач):
setTimeout(() => console.log("timeout 2")) будет ждать выполнения всех микрозадач и выполнится предпоследним
setTimeout(() => console.log("timeout 3")) выполнится последним, т.к. нет синхронного кода и очередь микрозадач пуста
*/
